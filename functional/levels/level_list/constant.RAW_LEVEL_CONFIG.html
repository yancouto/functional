<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `RAW_LEVEL_CONFIG` constant in crate `functional`."><title>RAW_LEVEL_CONFIG in functional::levels::level_list - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="functional" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0-nightly (3406ada96 2024-02-21)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-c37d3936c59ababd.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../functional/index.html">functional</a><span class="version">1.2.1</span></h2></div><div class="sidebar-elems"><h2><a href="index.html">In functional::levels::level_list</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../functional/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Constant <a href="../../index.html">functional</a>::<wbr><a href="../index.html">levels</a>::<wbr><a href="index.html">level_list</a>::<wbr><a class="constant" href="#">RAW_LEVEL_CONFIG</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/functional/levels/level_list.rs.html#40">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>const RAW_LEVEL_CONFIG: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] = b&quot;{\n   \&quot;sections\&quot;: [\n      {\n         \&quot;levels\&quot;: [\n            {\n               \&quot;description\&quot;: \&quot;A variable is a lower case letter from a to z.\\n\\nIf x is a variable, and M and N are terms, then:\\n- x is a term\\n- (x: M) is a term (called a function)\\n- (M N) is a term (called an application)\\n\\nExamples of terms:\\n- x\\n- x: x\\n- x: y: y x\\n- (x: x x) (y: z)\\n\\nParenthesis can be removed if order is clear. For example:\\n- (x: (y: x)) = x: y: x\\n- ((a b) c)   = a b c\\n\\nWrite any valid term.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;The goal of each level is to write a term that solves the problem statement. On this level, you simply need to write any valid term.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;anything\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;x\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: A\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;We can reduce the term (x: ...) B by replacing all free ocurrences of x in ... with B.\\n\\nSome examples:\\n- (x: y) z -&gt; y\\n- (x: x) z -&gt; z\\n- (x: x y) (z: z) -&gt; (z: z) y -&gt; y\\n- (x: (x: x) z) y -&gt; (x: x) z -&gt; z\\n- (x: x x) (x: x x) -&gt; (x: x x) (x: x x) -&gt; (x: x x) (x: x x) -&gt; ...\\n\\nEach step is called a reduction. More formally, if A and B are terms, then (x: A) B -&gt; A[x=B], where A[x=B] means replacing all ocurrences of variable x in A with the term B.\\n\\nWe say that the function (x: A) is applied to the term B.\\n\\nWrite an identity function, that is, a function that when applied to any term, reduces to that same term.\\n\\nExamples, assuming ID is the term you wrote on the editor below:\\n- ID a -&gt; a\\n- ID (x: a b) -&gt; (x: a b)\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;We say that (x: A) B reduces to A[x=B].\\n\\nFormally:\\n- If A = x, then A[x=B] = B\\n- If A = y, then A[x=B] = y\\n- If A = y: C, then A[x=B] = y: C[x=B]\\n- If A = x: C, then A[x=B] = x: C (this is called shadowing, as we have an inner ocurrence of x)\\n- If A = C D, then A[x=B] = C[x=B] D[x=B]\\n\&quot;,\n               \&quot;name\&quot;: \&quot;identity\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;x: x\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f A\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (x: x)\&quot;,\n                     \&quot;x:x\&quot;\n                  ],\n                  [\n                     \&quot;f: f (x: x) Z\&quot;,\n                     \&quot;Z\&quot;\n                  ],\n                  [\n                     \&quot;f: f (a:b:c: c b b a)\&quot;,\n                     \&quot;a:b:c: c b b a\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Functions in terms only accept a single parameter. However, you can simulate multiple arguments by having multiple chained functions.\\n\\nExample:\\n- (x: y: x) a b -&gt; (y: a) b -&gt; a\\n- (x: y: x y) a b -&gt; (y: a y) b -&gt; a b\\n\\nWrite a function F with two arguments that swaps the order of their terms, that is, it applies the second argument to the first.\\n\\nExamples, assuming F is the term you wrote on the editor below:\\n- F a b -&gt; b a\\n- F a (x: x) -&gt; (x: x) a -&gt; a\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Notice that terms are left associative, that is:\\n- a b c = ((a b) c)\\n\\nAnd that\&#39;s why you can call \\\&quot;multi parameter functions\\\&quot; like this:\\n- FUNC x y z = (((FUNC x) y) z)\\n\&quot;,\n               \&quot;name\&quot;: \&quot;two arguments\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;a:b: b a\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f A B\&quot;,\n                     \&quot;B A\&quot;\n                  ],\n                  [\n                     \&quot;f: f X (x: x)\&quot;,\n                     \&quot;X\&quot;\n                  ],\n                  [\n                     \&quot;f: f (x: x) A\&quot;,\n                     \&quot;A (y: y)\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Always remember that functions are also values.\\n\\nWrite a two argument function SQR that receives a function and a value, and applies the function to the value twice.\\n\\nExamples:\\n- SQR (x: x) y -&gt; (x: x) ((x: x) y) -&gt; (x: x) y -&gt; y\\n- SQR (x: x x) (y: y) -&gt; ... -&gt; (y: y)\\n\\nRemember that terms are left associative, that is:\\n- f f x = (f f) x\\n\\nWhich is not what we want in this problem, but instead \\\&quot;f (f x)\\\&quot;, which needs explicit parenthesization.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;The main objective of each level is to just write a term that solves the problem.\\n\\nHowever, you can also compare your stats to those of other players. Two stats are collected:\\n\\n- Reductions: How many steps your solution takes to solve the test cases, in average.\\n\\n- Functions: How many functions are used in your term. Note that this will be equal to the number of \&#39;:\&#39;.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;squaring\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;f:x: f (f x)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (x: x) A\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (x: x x) Z\&quot;,\n                     \&quot;(Z Z) ((x: x x) Z)\&quot;\n                  ],\n                  [\n                     \&quot;f: f (x: x x) (x: x)\&quot;,\n                     \&quot;(x: x)\&quot;\n                  ],\n                  [\n                     \&quot;f: f (x: x x x) (x: x)\&quot;,\n                     \&quot;(x: x)\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function SWAP_ARGS that receives a two argument function and will swap the values of the arguments it receives.\\n\\nExamples:\\n- SWAP_ARGS (a:b: a b) x y -&gt; (a:b: a b) y x -&gt; y x\\n- SWAP_ARGS (a:b: a a) x y -&gt; (a:b: a a) y x -&gt; y y\\n\&quot;,\n               \&quot;name\&quot;: \&quot;indirection\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;f:a:b: f b a\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (a:b: a b) C D\&quot;,\n                     \&quot;D C\&quot;\n                  ],\n                  [\n                     \&quot;f: f (a:b: a a) A B\&quot;,\n                     \&quot;B B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (a:b: a b) A (x: x)\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ]\n            }\n         ],\n         \&quot;name\&quot;: \&quot;basic\&quot;\n      },\n      {\n         \&quot;levels\&quot;: [\n            {\n               \&quot;before_level_constants\&quot;: [\n                  [\n                     \&quot;TRUE\&quot;,\n                     \&quot;a:b: a\&quot;\n                  ],\n                  [\n                     \&quot;FALSE\&quot;,\n                     \&quot;a:b: b\&quot;\n                  ]\n               ],\n               \&quot;description\&quot;: \&quot;We can define booleans as follows:\\n- TRUE  = a: b: a\\n- FALSE = a: b: b\\n\\nThat is, TRUE is a two argument function that returns the first element, and FALSE returns the second.\\n\\nWrite function IF, that is, a three-parameter function that is given a boolean, and two other values (say, A and B). If the boolean is TRUE, then it reduces to A, otherwise, it reduces to B. \\n\\nFor example:\\n- IF TRUE a b -&gt; a\\n- IF FALSE a b -&gt; b\\n\\nAs always, input is well formed, so the first argument is always a boolean.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;You can use constants from levels you have previously completed. See below for a full list of allowed constants. For TRUE and FALSE you don\&#39;t need to solve any level.\\n\\nIn a single section, you can solve levels in any order, and the order you chose will affect the constants you can use to solve each of them.\\n\\nLevels are not ordered by difficulty! Choose wisely.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;if\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;x: x\&quot;,\n                  \&quot;b:x:y: b x y\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE C D\&quot;,\n                     \&quot;D\&quot;\n                  ],\n                  [\n                     \&quot;f: f TRUE  C D\&quot;,\n                     \&quot;C\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function NOT, that is, a function that if given TRUE returns FALSE, and if given FALSE returns TRUE.\\n\\nTRUE and FALSE are the same as defined in the previous level.\\n\\nFor example:\\n- (NOT TRUE) a b -&gt; FALSE a b -&gt; b\\n\\nNote that you can assume that the used values are always booleans! Input is always well formed.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Notice that you don\&#39;t NEED to use the constants. And using them as little as possible means solving the problem using the least reductions.\\n\\nWhen we say NOT TRUE reduces to FALSE, we\&#39;re being somewhat loose with terminology. It reduces to a term that _behaves like_ TRUE, for example it could be \\\&quot;a:b: (x:y: x) a b\\\&quot;, which is not technically TRUE, but behaves like it.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;not\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;b: x:y: b y x\&quot;,\n                  \&quot;b: IF b FALSE TRUE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f TRUE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;f: f\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function AND, that is, a function that is given two booleans, and only reduces to TRUE if both values are TRUE.\\n\\nExamples:\\n- AND TRUE TRUE  -&gt; TRUE\\n- AND FALSE TRUE -&gt; FALSE\\n\\nAs always, the input is well formed, both arguments are booleans.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Notice that, when using constants, you don\&#39;t \\\&quot;pay\\\&quot; for their inner functions in your stats.\\n\\nSo writing (TRUE a b) and ((x:y: x) a b) both have the same effect, but the second one counts two extra functions in your stats.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;and\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;a:b: x:y: a (b x y) y\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f TRUE TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE TRUE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f TRUE FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function OR, that is, a function that is given two booleans, and only reduces to FALSE if both values are FALSE.\\n\\nExamples:\\n- OR FALSE FALSE -&gt; FALSE\\n- OR FALSE TRUE  -&gt; TRUE\\n\\nAs always, the input is well formed, both arguments are booleans.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;or\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;a:b: x:y: a x (b x y)\&quot;,\n                  \&quot;a:b: NOT (AND (NOT a) (NOT b))\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f TRUE TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f TRUE FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function XOR, that is, a function that is given two booleans, reduces to TRUE when exactly one of them is true.\\n\\nExamples:\\n- XOR FALSE FALSE -&gt; FALSE\\n- XOR TRUE TRUE   -&gt; FALSE\\n- XOR TRUE FALSE  -&gt; TRUE\\n\\nAs always, the input is well formed, both arguments are booleans.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;xor\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;a:b: x:y: a (b y x) (b x y)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f TRUE TRUE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f TRUE FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ]\n            }\n         ],\n         \&quot;name\&quot;: \&quot;boolean\&quot;\n      },\n      {\n         \&quot;levels\&quot;: [\n            {\n               \&quot;description\&quot;: \&quot;Let M and N be terms, we can define pairs as follows:\\n- (M, N) = f: f M N\\n\\nThat is, a pair of two elements is a function that receives one argument and applies both elements to it.\\n\\nWrite function PAIR that receives two arguments and returns a pair made of both elements.\\n\\nFor example:\\n- PAIR A B -&gt; (A, B) = f: f A B\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Remember you can solve levels from the same section in any order, and use constants from levels you\&#39;ve previously solved.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;pair\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;a:b: f: f a b\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;p: p A B\&quot;,\n                     \&quot;f: f A B\&quot;\n                  ],\n                  [\n                     \&quot;p: (p A B) (a:b: a)\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;p: (p A B) (a:b: b)\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function FST that receives a pair and returns the first element.\\n\\nFor example:\\n- FST (A, B) -&gt; A\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Notice that we\&#39;re using (A, B) in the examples, but that is not valid syntax for a term. When we write that, we actually mean (PAIR A B).\\n\&quot;,\n               \&quot;name\&quot;: \&quot;fst\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;p: p (a:b: a)\&quot;,\n                  \&quot;p: p TRUE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR A B)\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (x:x) X)\&quot;,\n                     \&quot;x:x\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (x:x) X) Z\&quot;,\n                     \&quot;Z\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;p: p FALSE\&quot;,\n                  \&quot;a:b: a\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function SND, a function that receives a pair and returns the second element.\\n\\nFor example:\\n- SND (A, B) -&gt; B\\n\&quot;,\n               \&quot;name\&quot;: \&quot;snd\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;p: p (a:b: b)\&quot;,\n                  \&quot;p: p FALSE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR A B)\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR X (x:x))\&quot;,\n                     \&quot;x: x\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR X (x:x)) Z\&quot;,\n                     \&quot;Z\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;A simple list can be create using pairs. It can be defined recursively as:\\n- An empty list is represented by FALSE.\\n- A list with one or more terms, is represented as (M, rest), where M is the first element and rest is the rest of the list.\\n\\nSo, for example:\\n- [a, b] = (a, (b, FALSE)) = f: f a (g: g b (x:y: y)) is a list of two elements.\\n\\nWrite a function that, given a list of five elements, reduces to the third.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;simple list\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;f: f FALSE FALSE TRUE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR A (PAIR B (PAIR C (PAIR D (PAIR E FALSE)))))\&quot;,\n                     \&quot;C\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR X (PAIR Y (PAIR Z (PAIR W (PAIR A FALSE)))))\&quot;,\n                     \&quot;Z\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function that, given a list of three booleans, reduces to TRUE if at least one of the booleans is TRUE, and to FALSE if all are FALSE.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;any\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;l: (OR (FST (SND (SND l))) (OR (FST l) (FST (SND l))))\&quot;,\n                  \&quot;l: l (a:b: (OR a (b (x:y: OR x (y TRUE)))))\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR FALSE (PAIR FALSE (PAIR FALSE FALSE))) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR TRUE (PAIR TRUE (PAIR TRUE FALSE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR TRUE (PAIR FALSE (PAIR FALSE FALSE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR FALSE (PAIR TRUE (PAIR FALSE FALSE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR FALSE (PAIR FALSE (PAIR TRUE FALSE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR FALSE (PAIR TRUE (PAIR TRUE FALSE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;OR OR\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function PUSH, that given a term M and a list L, reduces to a list with M as its first element (head) and L as the rest of the list (tail).\\n\\nFor example:\\n- PUSH A [B, C, D] -&gt; [A, B, C, D] = (A, (B, (C, (D, FALSE))))\\n\\nRemember, input is well formed, you can always assume the second argument is a valid list.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;push\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;PAIR\&quot;,\n                  \&quot;a:b: f: f a b\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f A FALSE\&quot;,\n                     \&quot;PAIR A FALSE\&quot;\n                  ],\n                  [\n                     \&quot;f: f A (PAIR B FALSE)\&quot;,\n                     \&quot;PAIR A (PAIR B FALSE)\&quot;\n                  ],\n                  [\n                     \&quot;f: f A (PAIR B (PAIR C FALSE))\&quot;,\n                     \&quot;PAIR A (PAIR B (PAIR C FALSE))\&quot;\n                  ],\n                  [\n                     \&quot;f: (f A B) TRUE\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function POP, that given a list L with at least one element, reduces to its tail (that is, the list of all elements except the first).\\n\\nFor example:\\n- POP [A, B, C, D, E] -&gt; [B, C, D, E]\\n\&quot;,\n               \&quot;name\&quot;: \&quot;pop\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;SND\&quot;,\n                  \&quot;l: l FALSE\&quot;,\n                  \&quot;l: l (h:t: t)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR (A) FALSE)\&quot;,\n                     \&quot;FALSE\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (PAIR A B) (PAIR (X) FALSE))\&quot;,\n                     \&quot;(PAIR (X) FALSE)\&quot;\n                  ],\n                  [\n                     \&quot;f: f (f (PAIR (A) (PAIR (B) (PAIR (C) (PAIR (D) FALSE)))))\&quot;,\n                     \&quot;(PAIR (C) (PAIR (D) FALSE))\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function EMPTY, that given a list L, reduces to TRUE if it\&#39;s empty, and FALSE if it\&#39;s not.\\n\\nFor example:\\n- EMPTY [A] = EMPTY (A, FALSE) -&gt; FALSE\\n- EMPTY [] = EMPTY FALSE -&gt; TRUE\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;If you have a list L, then \\\&quot;L A B\\\&quot; will resolve to B if L is empty, otherwise, it will resolve to \\\&quot;A h t B\\\&quot;, where h is the first element of the list and t is the rest of the list.\\n\\nYou can set A as a three argument function that receives the first element, the rest, and a dummy argument (which will always be B).\\n\\nThis is a generic way to deal with lists, and applicable in many other list problems.\\n\&quot;,\n               \&quot;extra_info_is_hint\&quot;: true,\n               \&quot;name\&quot;: \&quot;empty\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;l: l (h:t:x: FALSE) TRUE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR (A) FALSE) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (POP (PAIR (A) FALSE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PUSH A FALSE) A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ]\n            }\n         ],\n         \&quot;name\&quot;: \&quot;pair and list\&quot;\n      },\n      {\n         \&quot;levels\&quot;: [\n            {\n               \&quot;description\&quot;: \&quot;Write a term Y such that, for any term F, we have\\nY F = F (Y F)\\n\\nThis is called the Y-combinator. It is used to create recursion, because notice that:\\nY F = F (Y F) = F (F (Y F)) = F (F (F (F ... (Y F))))\\n\\nThis is always infite, but just because of that, it doesn\&#39;t mean that a reduction doesn\&#39;t exist. If A is an infinite term (doesn\&#39;t have a reduction) but B isn\&#39;t, then \\\&quot;(a:b: b) A B\\\&quot; is finite too.\\n\\nThis level is very hard. It\&#39;s mind twisting to create this recursive structure, feel free to skip it and go to the next level. Different from other constants, it is NOT necessary to complete this level to use the constant \\\&quot;Y\\\&quot; on following levels.\\n\\nThe most interesting part is actually using this result, not coming up with it.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;If you consider W = (x: x x), then W W -&gt; W W, the term reduces to itself.\\n\\nFor Y, you want to modify W in such a way that (f: W W) F -&gt; F ((f: W W) F).\\n\&quot;,\n               \&quot;extra_info_is_hint\&quot;: true,\n               \&quot;name\&quot;: \&quot;creating recursion\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;f: (x: f (x x)) (x: f (x x))\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;y: y (f: x: x) A\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;y: y (f: l: (l TRUE) (f (l FALSE))) (PAIR (x:Z) Y)\&quot;,\n                     \&quot;Z\&quot;\n                  ],\n                  [\n                     \&quot;y: y (f: l: (l TRUE) (f (l FALSE))) (PAIR (x: x C) (PAIR (x:A) B))\&quot;,\n                     \&quot;A C\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;before_level_constants\&quot;: [\n                  [\n                     \&quot;Y\&quot;,\n                     \&quot;f: (x: f (x x)) (x: f (x x))\&quot;\n                  ]\n               ],\n               \&quot;description\&quot;: \&quot;Using the Y combinator learned in previous problem, it\&#39;s possible to use recursion. Recursion is the act of writing a self referential function.\\n\\nSuppose you want to write a function that receives two arguments and applies *itself* to both arguments in inverted order. You can write:\\nF = Y (f: x:y: f y x)\\n\\nThat is, you can write a function that receives itself as the first argument and apply the Y combinator to it. That can be applied in fact to any function.\\n\\nWith that knowledge solve the following problem: you\&#39;re given a list of booleans. Write a function F that strips all the contiguous FALSE at the beginning of the list and returns the rest of the list.\\n\\nIt is guaranteed that the list has at least one TRUE, meaning the answer will be a non-empty list.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Examples for the problem:\\n- F [FALSE, FALSE, TRUE, TRUE, FALSE] -&gt; [TRUE, TRUE, FALSE]\\n- F [TRUE, FALSE] -&gt; [TRUE, FALSE]\\n- F [FALSE, TRUE] -&gt; [TRUE]\\n\\nLet\&#39;s reason why you can use Y in the way we said.\\n\\nLet F a self-referential function. Let\&#39;s write it as\\nF = (f: M) F\\n\\nwhere f in M are the locations in F that reference itself.\\n\\nIf we define F = Y (f: M), from the definition of Y, we have:\\nF = Y (f: M) = (f: M) (Y (f: M)) = (f: M) F = M[f=F]\\n\&quot;,\n               \&quot;name\&quot;: \&quot;strip prefix\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (f: p: (p TRUE) p (f (POP p)) )\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR (FALSE) (PAIR (FALSE) (PAIR (TRUE) (PAIR (TRUE) (PAIR (FALSE) FALSE)))))\&quot;,\n                     \&quot;(PAIR (TRUE) (PAIR (TRUE) (PAIR (FALSE) FALSE)))\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (FALSE) FALSE))\&quot;,\n                     \&quot;(PAIR (TRUE) (PAIR (FALSE) FALSE))\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (FALSE) (PAIR (TRUE) FALSE))\&quot;,\n                     \&quot;(PAIR (TRUE) FALSE)\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function ACC that takes as arguments a list L, a function F and a value I.\\n\\nF is a two argument function that reduces to a single argument.\\n\\nStarting the accumulated value X as I, replace X with F X Y for every element Y of the list L. Your function must then resolve to the last value of X.\\n\\nExamples:\\n- ACC [TRUE, FALSE] OR FALSE -&gt; TRUE\\n- ACC [] OR FALSE -&gt; FALSE\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;We call this process accumulation, and it is used to condense the values of a list to a single value.\\n\\nIn the examples, we\&#39;re taking the OR of a list of booleans, but this can be much more generic than that.\\n\\nRead the hint in the level \\\&quot;empty\\\&quot; if you\&#39;re stuck.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;acc\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;l:f:i: Y (g: l:x: l (h:t:d: g t (f x h)) x) l i\&quot;,\n                  \&quot;Y (g: l:f:i: l (h:t:d: g t f (f i h)) i)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (FALSE) FALSE)) OR FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (FALSE) (PAIR (FALSE) (PAIR (FALSE) FALSE))) OR FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE OR FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (FALSE) (PAIR (TRUE) FALSE))) XOR FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (FALSE) FALSE)) XOR FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function ALL that takes a list of booleans, and reduces to TRUE if all booleans are TRUE, and FALSE otherwise.\\n\\nIf the list is empty, it should reduce to TRUE, as in this case all the 0 booleans are TRUE.\\n\\nExamples:\\n- ALL [TRUE, TRUE, TRUE] -&gt; TRUE\\n- ALL [TRUE, FALSE] -&gt; FALSE\\n- ALL [] -&gt; TRUE\\n\\nThe input is always valid.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;all\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (f: l: l (h:t:d: h (f t) FALSE) TRUE)\&quot;,\n                  \&quot;l: ACC l AND TRUE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (TRUE) (PAIR (TRUE) FALSE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (FALSE) FALSE)) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (XOR TRUE FALSE) (PAIR (OR FALSE TRUE) FALSE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (TRUE) (PAIR (FALSE) (PAIR (TRUE) FALSE)))) A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function MAP that takes a list L and a function F, and reduces to a list with F applied to every element of L.\\n\\nExamples:\\n- MAP [TRUE, FALSE] NOT -&gt; [FALSE, TRUE]\\n- MAP [(A, B), (C, D)] FST -&gt; [A, C]\\n\&quot;,\n               \&quot;name\&quot;: \&quot;map\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;l:f: Y (g: l: l (h:t:d: PUSH (f h) (g t)) FALSE) l\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: (f (PAIR (PAIR A B) (PAIR (PAIR C D) FALSE)) FST) TRUE\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: (f (PAIR (PAIR E F) (PAIR (PAIR G H) FALSE)) SND) FALSE TRUE\&quot;,\n                     \&quot;H\&quot;\n                  ],\n                  [\n                     \&quot;f: ACC (f (PAIR (FALSE) (PAIR (FALSE) (PAIR (FALSE) FALSE))) NOT) AND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function NONE that takes a list of booleans, and reduces to TRUE if all booleans are FALSE, and FALSE otherwise.\\n\\nIf the list is empty, it should reduce to TRUE, as in this case all the 0 booleans are FALSE.\\n\\nExamples:\\n- NONE [FALSE, FALSE, FALSE] -&gt; TRUE\\n- NONE [TRUE, FALSE] -&gt; FALSE\\n- NONE [] -&gt; TRUE\\n\\nThe input is always valid.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;none\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (f: l: l (h:t:d: h FALSE (f t)) TRUE)\&quot;,\n                  \&quot;l: ALL (MAP l NOT)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (FALSE) (PAIR (FALSE) (PAIR (FALSE) FALSE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (FALSE) FALSE)) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (AND TRUE FALSE) (PAIR (OR FALSE FALSE) FALSE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (FALSE) (PAIR (FALSE) (PAIR (TRUE) (PAIR (FALSE) FALSE)))) A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function FILTER that takes a list L and a function F, and reduces to a list with all elements of L that when applied to F reduce to TRUE.\\n\\nExamples:\\n- FILTER [TRUE, FALSE] NOT -&gt; [FALSE]\\n- FILTER [(TRUE, TRUE), (TRUE, FALSE), (FALSE, TRUE)] FST -&gt; [(TRUE, TRUE), (TRUE, FALSE)]\\n\\nThe input is valid. F is a function that always reduces to a boolean when applied to an element of list L.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;filter\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;l:f: Y (g: l: l (h:t:d: (f h) (PUSH h (g t)) (g t)) FALSE) l\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f FALSE (x: TRUE) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (FALSE) (PAIR (AND TRUE FALSE) (PAIR (FALSE) FALSE))) (x: x) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PUSH (PAIR TRUE TRUE) (PUSH (PAIR FALSE FALSE) (PUSH (PAIR FALSE TRUE) FALSE))) (p: p XOR) FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PUSH (PAIR TRUE TRUE) (PUSH (PAIR FALSE FALSE) (PUSH (PAIR FALSE TRUE) FALSE))) (p: p XOR) TRUE (x:y: y (x B A) B)\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function ZIP that takes two lists, and reduces to the list of pairs with elements from the first and second list.\\n\\nYou can assume both lists have exactly the same number of elements.\\n\\nExamples:\\n- ZIP [A, B] [C, D] -&gt; [(A, C), (B, D)]\\n- ZIP [] [] -&gt; []\\n\\nThe input is always valid.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;zip\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (f: a:b: a (h:t:d: PUSH (PAIR h (b TRUE)) (f t (b FALSE))) FALSE)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR (A) FALSE) (PAIR (B) FALSE) TRUE FALSE\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (A) FALSE) (PAIR (B) FALSE) FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (A) (PAIR (B) FALSE)) (PAIR (C) (PAIR (D) FALSE)) FALSE TRUE TRUE\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: ACC (MAP (f (PAIR (TRUE) (PAIR (TRUE) (PAIR (FALSE) FALSE))) (PAIR (FALSE) (PAIR (TRUE) (PAIR (TRUE) FALSE)))) (p: p OR)) AND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function EQBLIST that takes two lists of booleans, and reduces to TRUE if they\&#39;re equal, and FALSE otherwise.\\n\\nYou can assume the lists have the same size.\\n\\nExamples:\\n- EQBLIST [] [] -&gt; TRUE\\n- EQBLIST [TRUE, FALSE] [TRUE, FALSE] -&gt; TRUE\\n- EQBLIST [TRUE] [FALSE] -&gt; FALSE\\n\&quot;,\n               \&quot;name\&quot;: \&quot;eqblist\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (f: a:b: a (h:t:d: ((b TRUE) h (x:y: h y x)) (f t (b FALSE)) FALSE) (x:y: b y x))\&quot;,\n                  \&quot;a:b: ACC (MAP (ZIP a b) (p: NOT (p XOR))) AND TRUE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f FALSE FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (FALSE) FALSE)) (PAIR (OR TRUE FALSE) (PAIR (AND TRUE FALSE) FALSE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (FALSE) FALSE)) (PAIR (TRUE) (PAIR (TRUE) FALSE)) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (FALSE) (PAIR (TRUE) (PAIR (TRUE) (PAIR (FALSE) FALSE))))) (PAIR (TRUE) (PAIR (FALSE) (PAIR (TRUE) (PAIR (TRUE) (PAIR (FALSE) FALSE))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (TRUE) (PAIR (FALSE) (PAIR (TRUE) (PAIR (TRUE) (PAIR (FALSE) FALSE))))) (PAIR (TRUE) (PAIR (FALSE) (PAIR (TRUE) (PAIR (FALSE) (PAIR (FALSE) FALSE))))) A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function CONCAT that takes two lists and reduces to the concatenation of the two lists.\\n\\nThat is, a list with all the elements from the first list, then all elements from the second list.\\n\\nExamples:\\n- CONCAT [A, B] [C] -&gt; [A, B, C]\\n- CONCAT [] [X] -&gt; [X]\\n\&quot;,\n               \&quot;name\&quot;: \&quot;concat\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (f: a:b: a (h:t:d: PUSH h (f t b)) b)\&quot;,\n                  \&quot;Y (f: a:b: (EMPTY a) b (PUSH (a TRUE) (f (a FALSE) b)))\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: EQBLIST (PAIR (FALSE) FALSE) (f FALSE (PAIR (FALSE) FALSE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: EQBLIST (PAIR (TRUE) FALSE) (f (PAIR (TRUE) FALSE) FALSE) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: EQBLIST (PAIR (TRUE) (PAIR (FALSE) (PAIR (FALSE) FALSE))) (f (PAIR (TRUE) (PAIR (FALSE) FALSE)) (PAIR (FALSE) FALSE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: EQBLIST (PAIR (FALSE) (PAIR (FALSE) (PAIR (FALSE) (PAIR (FALSE) (PAIR (TRUE) FALSE))))) (f (PAIR (FALSE) (PAIR (FALSE) FALSE)) (PAIR (FALSE) (PAIR (FALSE) (PAIR (TRUE) FALSE)))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: EQBLIST (PAIR (TRUE) (PAIR (FALSE) (PAIR (FALSE) (PAIR (FALSE) (PAIR (TRUE) (PAIR (TRUE) FALSE)))))) (f (PAIR (TRUE) (PAIR (FALSE) FALSE)) (f (PAIR (FALSE) (PAIR (FALSE) FALSE)) (PAIR (TRUE) (PAIR (TRUE) FALSE)))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: (f FALSE FALSE) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: (f (PAIR (A) FALSE) (PAIR (B) (PAIR (C) FALSE))) FALSE TRUE\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function REVERSE that takes a list, and reduces to the reversed list, that is, where the first element is now the last, the second is the second to last, and so on.\\n\\nExamples:\\n- REVERSE [a, b, c] -&gt; [c, b, a]\\n- REVERSE [x] -&gt; [x]\\n\\nThe input is always valid.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;reverse\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;l: Y (f: l: r: l (h:t:d: f t (PUSH h r)) r) l FALSE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR (A) (PAIR (B) (PAIR (C) FALSE))) TRUE\&quot;,\n                     \&quot;C\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (A) (PAIR (B) (PAIR (C) FALSE))) FALSE TRUE\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (A) (PAIR (B) (PAIR (C) FALSE))) FALSE FALSE TRUE\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: EMPTY (f FALSE) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (Z) FALSE) TRUE\&quot;,\n                     \&quot;Z\&quot;\n                  ]\n               ]\n            }\n         ],\n         \&quot;name\&quot;: \&quot;recursion\&quot;\n      },\n      {\n         \&quot;levels\&quot;: [\n            {\n               \&quot;description\&quot;: \&quot;We can define numerals as follows:\\nNumber N is (f:x: f^N x)\\n\\nThat is, it receives a function f and a value x, and applies f N times to x.\\n\\nFor example:\\n- 0 = (f:x: x)\\n- 2 = (f:x: f (f x))\\n\\nWrite function SUC that, given a numeral N, reduces to N+1.\\n\\nThe input is well formed, that is, it\&#39;s always a numeral.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Notice that our numerals are all non-negative.\\n\\nRemember you can solve levels from the same section in any order, and use constants from levels you\&#39;ve previously solved.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;suc\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;n: (f:x: f (n f x))\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 0 (x: A) B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 0 SND (PAIR (Z) TRUE) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 9 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;n: (f:x: f n)\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function ZERO that, given a numeral N, reduces to TRUE if it\&#39;s zero, and FALSE if it\&#39;s not.\\n\\nThe input is well formed, that is, it\&#39;s always a numeral.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Notice that this definition of numeral is quite arbitrary.\\n\\nIn fact, the same is true for booleans, pairs and lists. They could be defined in other ways, as long as the same operations could still be done using them.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;zero\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;n: n (x: FALSE) TRUE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 0 A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (SUC 0) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f 3 A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f 5 A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;n: n FALSE TRUE\&quot;,\n                  \&quot;n: n\&quot;,\n                  \&quot;SND\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function PRE that, given a numeral N, reduces to N-1.\\n\\nIf N is zero, then PRE N should reduce to zero.\\n\\nThe input is well formed, that is, it\&#39;s always a numeral.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Any numeral definition that supports SUC, PRE and ZERO operations are equivalent, even though they may be very different.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;pre\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;n: f:x: n (g:h: h (g f)) (u: x) (u: u)\&quot;,\n                  \&quot;n: f:x: n (p: p (h:t: h (PAIR FALSE x) (PAIR FALSE (f t)))) (PAIR TRUE x) FALSE\&quot;,\n                  \&quot;n: (n (a:f: f z a) FALSE) (h:t:d: f:x: Y (g: l: l (h:t:d: f (g t)) x) t ) FALSE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: ZERO (f 1) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: ZERO (f 2) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f 0 SND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 3 SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 10 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 15 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))))))))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;n: f:x: n f (i: i) x\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function ADD that, given two numerals X and Y, reduces to X+Y.\\n\\nThe input is well formed, that is, it\&#39;s always two numerals.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;It\&#39;s possible to write this function using only SUC, PRE and ZERO, and it would work for any numeral definition.\\n\\nHowever, you can use the specifics of this definition to make it easier if you wish.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;add\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;a:b: f:x: b f (a f x)\&quot;,\n                  \&quot;Y (f: a:b: (ZERO a) b (SUC (f (PRE a) b)))\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 3 2 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 3 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: ZERO (f 0 0) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 0 SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 0 2 SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 5 5 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;a:b: a b\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function SUB that, given two numerals X and Y, reduces to X-Y.\\n\\nIf Y is greater than X, it should reduce to 0 instead.\\n\\nThe input is well formed, that is, it\&#39;s always two numerals.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;sub\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (f: a:b: (ZERO b) a (PRE (f a (PRE b))))\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: ZERO (f 0 0) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 0 SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 0 2 SND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 7 3 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 3 7 SND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 7 (f 4 2) SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: ADD 2 (f 1 2) SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;Y (f: a:b: (ZERO a) b (SUC (f (PRE a) b)))\&quot;,\n                  \&quot;a:b: f:x: b f (a f x)\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function MUL that, given two numerals X and Y, reduces to X.Y, that is, X multiplied by Y.\\n\\nExamples:\\n- MUL 2 3 -&gt; 6\\n- MUL 0 5 -&gt; 0\\n\\nThe input is well formed, that is, it\&#39;s always two numerals.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;mul\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;a:b: f:x: a (b f) x\&quot;,\n                  \&quot;Y (f: a:b: (ZERO a) 0 ((ZERO (PRE a)) b (ADD b (f (PRE a) b))))\&quot;,\n                  \&quot;Y (f: a:b: (ZERO a) 0 ((ZERO (PRE a)) b (ADD (ADD b b) (f (PRE (PRE a)) b))))\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 3 2 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 3 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: ZERO (f 0 0) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 0 SND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 0 2 SND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 1 3 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 5 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;a:b: a b\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function DIV that, given two numerals X and Y, reduces to X/Y, that is, X divided by Y.\\n\\nExamples:\\n- DIV 6 3 -&gt; 2\\n- DIV 3 1 -&gt; 3\\n- DIV 0 2 -&gt; 0\\n\\nIt is guaranteed that X is always divisible by Y.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;div\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;a:b: Y (f: a: ZERO a 0 (ADD 1 (f (SUB a b)))) a\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 6 3 SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 6 2 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 2 SND (PAIR (Z) TRUE) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 1 1 SND (PAIR (Z) TRUE) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 4 1 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 25 5 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 0 2 SND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function eq that, given two numerals X and Y, reduces to TRUE if X = Y and FALSE otherwise.\\n\\nExamples:\\n- EQ 1 1 -&gt; TRUE\\n- EQ 1 0 -&gt; FALSE\\n    \\nThe input is well formed, that is, it\&#39;s always two numerals.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;eq\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;x:y: AND (ZERO (SUB x y)) (ZERO (SUB y x))\&quot;,\n                  \&quot;x:y: ZERO (x (z: ZERO z 100 (PRE z)) y)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 0 0 A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 1 1 A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 1 A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 4 A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f 5 (ADD 2 3) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;x:y: ZERO (SUB x y)\&quot;,\n                  \&quot;x:y: ZERO (SUB y x)\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function MIN that, given two numerals X and Y, reduces to the smallest of them.\\n\\nThe input is well formed.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;min\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;x:y: ZERO (SUB x y) x y\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 3 2 SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 3 SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 5 0 SND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 1 1 SND (PAIR (Z) TRUE) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;SUB\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function MAX that, given two numerals X and Y, reduces to the largest of them.\\n\\nThe input is well formed.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;max\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;x:y: ZERO (SUB x y) y x\&quot;,\n                  \&quot;x:y: ADD (SUB x y) y\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 3 2 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 3 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 5 0 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 1 1 SND (PAIR (Z) TRUE) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;SUB ADD\&quot;,\n                  \&quot;x:y: ZERO (SUB x y) x y\&quot;\n               ]\n            }\n         ],\n         \&quot;name\&quot;: \&quot;numerals\&quot;\n      },\n      {\n         \&quot;levels\&quot;: [\n            {\n               \&quot;description\&quot;: \&quot;Write a function ISODD that takes one number N and reduces to TRUE if it is odd, or FALSE if it is even.\\n\\nExamples:\\n- F 0 -&gt; FALSE\\n- F 1 -&gt; TRUE\\n- F 32 -&gt; FALSE\\n\&quot;,\n               \&quot;name\&quot;: \&quot;is odd\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;n: n NOT FALSE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 0 A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f 1 A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 2 A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f 9 A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 12 A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;n: n NOT\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function F that takes one number N and reduces to the list of numbers up to it.\\n\\nExamples:\\n- F 0 -&gt; [0]\\n- F 3 -&gt; [0, 1, 2, 3]\\n\&quot;,\n               \&quot;name\&quot;: \&quot;increasing list\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;n: Y (f: a: ZERO a (PAIR n FALSE) (PUSH (SUB n a) (f (PRE a)))) n\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 0 FST SND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: EMPTY (POP (f 0)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 4 FALSE FALSE TRUE SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: 5 SND (f 5) TRUE SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: EMPTY (4 SND (f 3)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;n: (f:x: f n)\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function DEC that, given a number X, outputs its decomposition in increasing powers of two. That is, it should output a list of unique increasing powers of two, such that its sum is X. It is guaranteed such decomposition always exists and is unique.\\n\\nFor example:\\n- DEC 12 -&gt; [4, 8]\\n- DEC 8 -&gt; [8]\\n- DEC 15 -&gt; [1, 2, 4, 8]\\n\\nX is at most 15.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;decompositon\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;x: REVERSE (Y (f: x: p: p (h:t:d: ZERO (SUB x (SUB h 1)) (f x t) (PUSH h (f (SUB x h) t))) FALSE) x (PAIR 8 (PAIR 4 (PAIR 2 (PAIR 1 FALSE)))))\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 5 (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 8 (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))))) (t (h:t:x: FALSE) TRUE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 13 (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 15 (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 10 (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 0 (h:t:x: FALSE) TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 1 (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: FALSE) TRUE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function PRIM that, given a number X, outputs its decomposition in increasing primes. That is, it should output a list of increasing primes, such that the multiplication of all its elements is X. It is guaranteed such decomposition always exists and is unique.\\n\\nA prime number is a number greater than 1 which is only divisible by 1 and itself.\\n\\nFor example:\\n- PRIM 12 -&gt; [2, 2, 3]\\n- PRIM 7 -&gt; [7]\\n- PRIM 15 -&gt; [3, 5]\\n\\nX is at least 2 and at most 50.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;primes\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;x: Y (f: p: x:\\np\\n  (h:t:d:\\n    ZERO (x (y: ZERO y (PRE h) (PRE y)) h)\\n      (PUSH h (f p (DIV x h)))\\n      (f t x)\\n  )\\n  (ZERO (PRE x) FALSE (PUSH x FALSE))\\n)\\n(PUSH 2 (PUSH 3 FALSE)) x\\n\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f 2 (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: FALSE) TRUE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 7 (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))))) (t (h:t:x: FALSE) TRUE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 12 (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 13 (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))))))))))) (t (h:t:x: FALSE) TRUE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f 9 (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function SORT that, given a list of numbers, reduces to the same elements, ordered from smallest to largest.\\n\\nFor example:\\n- SORT [2] -&gt; [2]\\n- SORT [4, 3] -&gt; [3, 4]\\n- SORT [1, 3, 2] -&gt; [1, 2, 3]\\n\\nThe list has at least one element and at most 4. All elements are distinct.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;sort\&quot;,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (f: l:\\nl\\n  (h:t:d:\\n    (CONCAT\\n      (f (FILTER t (x: (ZERO (SUB x h)))))\\n      (PUSH h (f (FILTER t (x: (ZERO (SUB h x))))))\\n  ))\\n  FALSE\\n)\\n\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (PAIR (2) FALSE) (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: FALSE) TRUE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (4) (PAIR (3) FALSE)) (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (1) (PAIR (3) (PAIR (2) FALSE))) (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (4) (PAIR (2) (PAIR (1) (PAIR (3) FALSE)))) (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (7) (PAIR (5) (PAIR (3) (PAIR (2) FALSE)))) (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;x: x\&quot;,\n                  \&quot;REVERSE\&quot;\n               ]\n            }\n         ],\n         \&quot;name\&quot;: \&quot;more numerals\&quot;\n      },\n      {\n         \&quot;levels\&quot;: [\n            {\n               \&quot;description\&quot;: \&quot;Let L, V and R be terms, we define a tree node as follows:\\n- (L V R) = f: f L V R\\n\\nThat is, a function that receives one argument and applies it to L, V and R.\\n\\nWrite NODE, a function that receives three arguments L, V and R, and returns a tree node made of the three elements.\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;You can see a tree node is very similar to a pair, but made of three elements. We will use it to build the definition of a tree in the following problems.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;node\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;l:v:r: f: f l v r\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;n: n L V R\&quot;,\n                     \&quot;f: f L V R\&quot;\n                  ],\n                  [\n                     \&quot;n: (n L V R) (a:b:c: a)\&quot;,\n                     \&quot;L\&quot;\n                  ],\n                  [\n                     \&quot;n: (n L V R) (a:b:c: b)\&quot;,\n                     \&quot;V\&quot;\n                  ],\n                  [\n                     \&quot;n: (n L V R) (a:b:c: c)\&quot;,\n                     \&quot;R\&quot;\n                  ],\n                  [\n                     \&quot;n: (n (x: x x) (x: B) A) (a:b:c: a c)\&quot;,\n                     \&quot;A A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;PAIR\&quot;,\n                  \&quot;l:r:v: f: f l v r\&quot;,\n                  \&quot;l:v:r: l v r\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function LEF that receives a node and returns the first element.\\n\\nFor example:\\n- LEF (L V R) -&gt; L\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;We call it LEF as a shorthand for left, as on the next problems it will be used to retrieve the left child of the node.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;lef\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;n: n (l:v:r: l)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (NODE L V R)\&quot;,\n                     \&quot;L\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (x:x) A B)\&quot;,\n                     \&quot;x:x\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;n: L\&quot;,\n                  \&quot;l:v:r: l\&quot;,\n                  \&quot;n: (l: l)\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function RIG that receives a node and returns the last element.\\n\\nFor example:\\n- RIG (L V R) -&gt; R\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;We call it RIG as a shorthand for right, as on the next problems it will be used to retrieve the right child of the node.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;rig\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;n: n (l:v:r: r)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (NODE L V R)\&quot;,\n                     \&quot;R\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE A B (x:x))\&quot;,\n                     \&quot;x:x\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;n: R\&quot;,\n                  \&quot;l:v:r: r\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function VAL that receives a node and returns the middle element.\\n\\nFor example:\\n- VAL (L V R) -&gt; V\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;We call it VAL as a shorthand for value, as on the next problems it will be used to retrieve the value stored in the node.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;val\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;n: n (l:v:r: v)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (NODE L V R)\&quot;,\n                     \&quot;V\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE A (x:x) B)\&quot;,\n                     \&quot;x:x\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;n: V\&quot;,\n                  \&quot;l:v:r: v\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;A binary tree is a data structure made of tree nodes. Each node may have a left and a right child (the L and R terms in it) and always contains a value (the term V). We use FALSE to indicate an empty binary tree, or to show that a node doesn\&#39;t have a left or right child.\\n\\nWrite a function BEMPTY that given a binary tree returns whether it is empty or not.\\n\\nFor example:\\n- BEMPTY (FALSE 1 FALSE) -&gt; FALSE\\n- BEMPTY FALSE -&gt; TRUE\\n- BEMPTY ((FALSE 2 FALSE) 1 FALSE) -&gt; FALSE\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;More formally, if L and R are binary trees and V is any term then:\\n- FALSE is an empty binary tree (no values).\\n- (L V R) is a binary tree with value V, and all values from the trees L and R.\\n\\nSo ((FALSE 4 (FALSE 20 FALSE)) 4 (FALSE TRUE FALSE)) is a binary tree with values 4, 20, 4, and TRUE.\\n\\nIf you need a hint, look at the hint for the \\\&quot;empty\\\&quot; level in the \\\&quot;pair and list\\\&quot; section.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;bempty\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;n: n (l:v:r:t: FALSE) TRUE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (NODE FALSE TRUE FALSE) A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE FALSE FALSE) 2 (NODE FALSE 3 FALSE)) A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;NOT\&quot;,\n                  \&quot;EMPTY\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function FIND that takes a binary search tree B and a value V and returns TRUE if V is in any node of B or FALSE otherwise.\\n\\nExamples:\\n- FIND ((1) 2 (3)) 1 -&gt; TRUE\\n- FIND ((1) 2 (3)) 5 -&gt; FALSE\\n\&quot;,\n               \&quot;name\&quot;: \&quot;find\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (f: b:x: b (l:v:r:z: ZERO (SUB x v) (ZERO (SUB v x) TRUE (f l x)) (f r x)) FALSE)\&quot;,\n                  \&quot;Y (f: b:x: b (l:v:r:z: (EQ v x) TRUE (ZERO (SUB x v) (f l x) (f r x))) FALSE)\&quot;,\n                  \&quot;Y (f: b:x: b (l:v:r:z: (EQ v x) TRUE (OR (f l x) (f r x))) FALSE)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 FALSE) 2 (NODE FALSE 3 FALSE)) 1 A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 2 FALSE) 3 FALSE) 5 A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE 0 A B\&quot;,\n                     \&quot;B\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 3 (NODE FALSE 4 FALSE)) 5 (NODE FALSE 6 FALSE)) 4 A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 2 (NODE FALSE 3 FALSE)) 5 (NODE FALSE 6 FALSE)) 4 A B\&quot;,\n                     \&quot;B\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;b:x: TRUE\&quot;,\n                  \&quot;b:x: b (l:v:r: EQ v x)\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write function BSIZE that takes a binary tree and outputs its size, that is, it ignores all its values and outputs the total number of nodes in the tree.\\n\\nFor example:\\n- BSIZE (FALSE 10 FALSE) -&gt; 1\\n- BSIZE (FALSE TRUE (FALSE FALSE FALSE)) -&gt; 2\\n\&quot;,\n               \&quot;name\&quot;: \&quot;bsize\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (y: n: n (l:v:r:z: SUC (ADD (y l) (y r))) 0)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f FALSE SND TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE FALSE FALSE FALSE) SND (PAIR (Z) TRUE) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE FALSE 1 (NODE FALSE 2 (NODE FALSE 3 FALSE))) SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 FALSE) 2 (NODE FALSE 3 FALSE)) SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 (NODE FALSE 2 FALSE)) 3 (NODE (NODE FALSE 4 FALSE) 6 FALSE)) SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;VAL\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;A binary search tree (BST) is a binary tree where all values are &lt;distinct&gt; integers, and it follows this property:\\nFor a node (L V R), all values in the subtree L are less than V, and all values in the subtree R are more than V.\\n\\nYou can insert a new value X in a BST by starting at the root node and:\\n- If the root node is empty, create a node (FALSE X FALSE).\\n- Otherwise if (L V R) is not empty and X &gt; V, insert X in R.\\n- Otherwise, X &lt; V and you should insert X in L.\\n\\nWrite function BUILD that given an array of integers, inserts them in order in an empty tree and returns the result.\\n\\nFor example:\\n- BUILD [5] -&gt; (5)\\n- BUILD [2, 1, 3] -&gt; ((1) 2 (3))\\n- BUILD [1, 3, 2] -&gt; (1 ((2) 3))\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Binary search trees are just a fancy way of storing a sorted array.\\n\\nOn the (L V R) notation, we can hide L and R if they are FALSE, which makes the notation easier to read, and still conveys all the same information.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;build\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;a: ACC a (Y (f: b:x: b (l:v:r:t: (ZERO (SUB x v)) (NODE (f l x) v r) (NODE l v (f r x)) ) (NODE FALSE x FALSE) )) FALSE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f FALSE (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) (FALSE)) TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (2) FALSE) (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) ((NODE FALSE 2 FALSE))) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (1) (PAIR (2) (PAIR (3) FALSE))) (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) ((NODE FALSE 1 (NODE FALSE 2 (NODE FALSE 3 FALSE))))) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (3) (PAIR (2) (PAIR (4) FALSE))) (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) ((NODE (NODE FALSE 2 FALSE) 3 (NODE FALSE 4 FALSE)))) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (PAIR (4) (PAIR (3) (PAIR (5) (PAIR (1) (PAIR (2) FALSE))))) (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) ((NODE (NODE (NODE FALSE 1 (NODE FALSE 2 FALSE)) 3 FALSE) 4 (NODE FALSE 5 FALSE)))) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;NODE\&quot;,\n                  \&quot;x:x\&quot;,\n                  \&quot;a: ACC a (Y (f: b:x: b (l:v:r:t: (ZERO (SUB v x)) (NODE (f l x) v r) (NODE l v (f r x)) ) (NODE FALSE x FALSE) )) FALSE\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function PREORDER that takes a binary tree and returns an array.\\n\\nThis should use preorder traversal. For a node (L V R):\\n- First, add all values in L to the array.\\n- Then, add V to the array.\\n- Then, add all values in R to the array.\\n\\nExamples:\\n- PREORDER ((1) 2 (3)) -&gt; [1, 2, 3]\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Note that on a BST b using (PREORDER b) will return a sorted array.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;preorder\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;(b: (Y (f: b:p: b (l:v:r:p: f l (PUSH v (f r p))) p)) b FALSE)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 FALSE) 2 (NODE FALSE 3 FALSE)) (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE (h:t:x: FALSE) TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE (NODE FALSE 2 FALSE) 3 FALSE) 4 FALSE) (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 (NODE FALSE 3 FALSE)) 4 (NODE (NODE FALSE 5 FALSE) 6 (NODE FALSE 7 FALSE))) (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;(b: (Y (f: b:p: b (l:v:r:p: PUSH v (f l (f r p))) p)) b FALSE)\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function INORDER that takes a binary tree and returns an array.\\n\\nThis should use inorder traversal. For a node (L V R):\\n- First, add V to the array.\\n- Then, add all values in L to the array.\\n- Then, add all values in R to the array.\\n\\nExamples:\\n- INORDER ((1) 2 (3)) -&gt; [2, 1, 3]\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Note that on a BST b using (BUILD (INORDER b)) will reconstruct the same BST with exactly the same shape.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;inorder\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;(b: (Y (f: b:p: b (l:v:r:p: PUSH v (f l (f r p))) p)) b FALSE)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 FALSE) 2 (NODE FALSE 3 FALSE)) (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE (h:t:x: FALSE) TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE FALSE 2 (NODE FALSE 3 (NODE FALSE 4 FALSE))) (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 (NODE FALSE 3 FALSE)) 4 (NODE (NODE FALSE 5 FALSE) 6 (NODE FALSE 7 FALSE))) (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;(b: (Y (f: b:p: b (l:v:r:p: f l (PUSH v (f r p))) p)) b FALSE)\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function SPLIT that, given a binary search tree T and a number X, returns a pair (A, B) where:\\n- A is a BST with all values of T that are less than X.\\n- B is a BST with all values of T that are more than X.\\n\\nA and B should roughly maintain the same shape as T.\\nIt is guaranteed that X is NOT present in T.\\n\\nExamples:\\n- SPLIT ((1) 3 (4)) 2 -&gt; ((1), (3 (4)))\\n- SPLIT (5) 3 -&gt; (FALSE, (5))\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;When we say \\\&quot;roughly maintain the same shape\\\&quot;, we mean:\\nIf Y and Z are numbers from the tree T and Z is a (recursive) child of Y, plus both are smaller or both are greater than X, then in the resulting tree they should mantain the fact that Z is a (recursive) child of Y.\\n\\nIn general terms, you should modify the tree as little as possible when splitting it up in subtrees.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;split\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;Y (f: b:x: b (l:v:r:z: (ZERO (SUB x v)) ((f l x) (a:b: (PAIR a (NODE b v r)))) ((f r x) (a:b: (PAIR (NODE l v a) b) ))) (PAIR FALSE FALSE))\&quot;,\n                  \&quot;b:x: (a: (PAIR (BUILD (FILTER a (y: ZERO (SUB y x)))) (BUILD (FILTER a (y: ZERO (SUB x y)))))) (INORDER b)\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: (f (NODE (NODE FALSE 1 FALSE) 3 (NODE FALSE 5 FALSE)) 2) (a:b: AND ((b: b (l:v:r: AND ((n: n SND (PAIR (Z) TRUE)) v) (l FALSE (NOT r)))) a) ((b: b (l:v:r: AND ((n: n SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) v) (AND (BEMPTY l) (r (l:v:r: AND ((n: n SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) v) (l FALSE (NOT r))))))) b)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: (f (NODE (NODE (NODE FALSE 1 FALSE) 2 (NODE FALSE 4 FALSE)) 5 (NODE FALSE 6 FALSE)) 3) (a:b: AND ((b: b (l:v:r: AND ((n: n SND (PAIR (Z) (PAIR (Z) TRUE))) v) (AND (l (l:v:r: AND ((n: n SND (PAIR (Z) TRUE)) v) (l FALSE (NOT r)))) (BEMPTY r)))) a) ((b: b (l:v:r: AND ((n: n SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) v) (AND (l (l:v:r: AND ((n: n SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) v) (l FALSE (NOT r)))) (r (l:v:r: AND ((n: n SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))) v) (l FALSE (NOT r))))))) b)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: (f FALSE 3) (a:b: AND (BEMPTY a) (BEMPTY b)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: (f (NODE (NODE FALSE 1 FALSE) 2 (NODE (NODE FALSE 3 FALSE) 4 (NODE FALSE 6 FALSE))) 5) (a:b: AND ((b: b (l:v:r: AND ((n: n SND (PAIR (Z) (PAIR (Z) TRUE))) v) (AND (l (l:v:r: AND ((n: n SND (PAIR (Z) TRUE)) v) (l FALSE (NOT r)))) (r (l:v:r: AND ((n: n SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) v) (AND (l (l:v:r: AND ((n: n SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) v) (l FALSE (NOT r)))) (BEMPTY r))))))) a) ((b: b (l:v:r: AND ((n: n SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))) v) (l FALSE (NOT r)))) b)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;b:x: PAIR FALSE b\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function KTH that, given a binary search tree B and a positive number K, returns the k-th smallest value in B (0-indexed).\\n\\nIt is guaranteed that B always has at least K + 1 elements.\\n\\nExamples:\\n- KTH ((2) 4 (6)) 0 -&gt; 2\\n- KTH ((2) 4 (6)) 1 -&gt; 4\\n- KTH ((2) 4 (6)) 2 -&gt; 6\\n\&quot;,\n               \&quot;extra_info\&quot;: \&quot;Try to avoid visiting the whole tree, it may be big.\\n\&quot;,\n               \&quot;name\&quot;: \&quot;kth\&quot;,\n               \&quot;provides_constant\&quot;: true,\n               \&quot;solutions\&quot;: [\n                  \&quot;b:x: SND (Y (f: b:p: b (l:v:r:z: f l p (i:o: i (h:t:z: h (PAIR FALSE v) (f r t)) (PAIR i o))) (PAIR p p)) b (x (p: PAIR FALSE p) (PAIR TRUE FALSE)))\&quot;,\n                  \&quot;b:x: SND (Y (f: b:x: b (l:v:r:z: f l x (i:o: ZERO i (PAIR 0 o) (ZERO (PRE i) (PAIR 0 v) (f r (PRE i))))) (PAIR x x)) b (SUC x))\&quot;,\n                  \&quot;b:x: FST (x POP (PREORDER b))\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 FALSE) 3 (NODE FALSE 5 FALSE)) 1 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 FALSE) 3 (NODE FALSE 5 FALSE)) 2 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE FALSE 2 FALSE) 0 SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 3 (NODE FALSE 4 FALSE)) 5 FALSE) 1 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 FALSE) 3 FALSE) 0 SND (PAIR (Z) TRUE) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE (NODE FALSE 2 (NODE FALSE 3 FALSE)) 4 (NODE FALSE 6 FALSE)) 7 (NODE (NODE (NODE FALSE 8 (NODE FALSE 9 FALSE)) 11 (NODE FALSE 12 FALSE)) 15 (NODE FALSE 19 FALSE))) 3 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE (NODE FALSE 2 (NODE FALSE 3 FALSE)) 4 (NODE FALSE 6 FALSE)) 7 (NODE (NODE (NODE FALSE 8 (NODE FALSE 9 FALSE)) 11 (NODE FALSE 12 FALSE)) 15 (NODE FALSE 19 FALSE))) 2 SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;b:x: b (l:v:r: v)\&quot;\n               ]\n            },\n            {\n               \&quot;description\&quot;: \&quot;Write a function F that, given a binary search tree with distinct values between 1 and 6, returns an ordered array with all 1-6 numbers that are NOT in the tree.\\n\\nFor example:\\n- F ((FALSE 1 FALSE) 3 (FALSE 4 FALSE)) -&gt; [2, 5, 6]\\n- F FALSE -&gt; [1, 2, 3, 4, 5, 6]\\n\&quot;,\n               \&quot;name\&quot;: \&quot;inverse 6\&quot;,\n               \&quot;provides_constant\&quot;: false,\n               \&quot;solutions\&quot;: [\n                  \&quot;b: FILTER (PUSH 1 (PUSH 2 (PUSH 3 (PUSH 4 (PUSH 5 (PUSH 6 FALSE)))))) (x: (Y (f: b:x: b (l:v:r:t: (EQ v x) FALSE ((ZERO (SUB v x)) (f r x) (f l x))) TRUE)) b x)\&quot;,\n                  \&quot;t: Y (f: t:a:b:p: t (l:v:r:z: f l a (PRE v) (f r v b p)) ((ZERO (SUB b a)) p (f FALSE a (PRE b) (PUSH b p)))) t 0 6 FALSE\&quot;\n               ],\n               \&quot;test_cases\&quot;: [\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 2 FALSE) 4 (NODE FALSE 6 FALSE)) (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 (NODE FALSE 2 FALSE)) 3 (NODE (NODE FALSE 4 FALSE) 5 (NODE FALSE 6 FALSE))) (h:t:x: FALSE) TRUE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f (NODE (NODE FALSE 1 FALSE) 3 (NODE FALSE 5 FALSE)) (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ],\n                  [\n                     \&quot;f: f FALSE (h:t:x: AND (h SND (PAIR (Z) TRUE)) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE)) FALSE)) FALSE)) FALSE)) FALSE A B\&quot;,\n                     \&quot;A\&quot;\n                  ]\n               ],\n               \&quot;wrong_solutions\&quot;: [\n                  \&quot;x: x\&quot;,\n                  \&quot;t: Y (f: t:a:b:p: t (l:v:r:z: (f r v b (f l a (PRE v) p)) ((ZERO (SUB b a)) p (f FALSE a (PRE b) (PUSH b p)))) t 0 6 FALSE\&quot;\n               ]\n            }\n         ],\n         \&quot;name\&quot;: \&quot;trees\&quot;\n      }\n   ],\n   \&quot;tests\&quot;: [\n      [\n         \&quot;TRUE A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;FALSE A B\&quot;,\n         \&quot;B\&quot;\n      ],\n      [\n         \&quot;AND TRUE TRUE A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;(a:b: (x:y: x) a b) A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;(a:b: (x:y: y) a b) A B\&quot;,\n         \&quot;B\&quot;\n      ],\n      [\n         \&quot;FALSE A B\&quot;,\n         \&quot;B\&quot;\n      ],\n      [\n         \&quot;(PAIR (A) FALSE) FALSE A B\&quot;,\n         \&quot;B\&quot;\n      ],\n      [\n         \&quot;(PAIR (A) FALSE) TRUE\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;(PAIR (A) (PAIR (B) (PAIR (C) (PAIR (D) FALSE)))) FALSE FALSE TRUE\&quot;,\n         \&quot;C\&quot;\n      ],\n      [\n         \&quot;(f:x: x) SND TRUE A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;(FALSE) SND TRUE A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;(f:x: f x) SND (PAIR (Z) TRUE) A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;(f:x: f (f x)) SND (PAIR (Z) (PAIR (Z) TRUE)) A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;(5) SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))))) A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;PAIR 5 FALSE (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))))) (t (h:t:x: FALSE) TRUE)) FALSE A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;PAIR 3 (PAIR 2 FALSE) (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE)))) (t (h:t:x: AND (h SND (PAIR (Z) (PAIR (Z) TRUE))) (t (h:t:x: FALSE) TRUE)) FALSE)) FALSE A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;FALSE A B\&quot;,\n         \&quot;B\&quot;\n      ],\n      [\n         \&quot;(NODE FALSE 3 FALSE) (l:v:r: v) SND (PAIR (Z) (PAIR (Z) (PAIR (Z) TRUE))) A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;(NODE (NODE FALSE 1 FALSE) 2 FALSE)\&quot;,\n         \&quot;NODE (NODE FALSE 1 FALSE) 2 FALSE\&quot;\n      ],\n      [\n         \&quot;(x:A) (NODE (NODE FALSE 1 FALSE) 2 (NODE FALSE 3 FALSE))\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;FALSE (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) (FALSE)) TRUE A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;FALSE (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) ((NODE FALSE 1 FALSE))) FALSE A B\&quot;,\n         \&quot;B\&quot;\n      ],\n      [\n         \&quot;(NODE FALSE 1 (NODE FALSE 2 (NODE FALSE 3 FALSE))) (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) ((NODE FALSE 1 (NODE FALSE 2 (NODE FALSE 3 FALSE))))) FALSE A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;(NODE (NODE FALSE 1 FALSE) 2 (NODE FALSE 3 FALSE)) (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) ((NODE (NODE FALSE 1 FALSE) 2 (NODE FALSE 3 FALSE)))) FALSE A B\&quot;,\n         \&quot;A\&quot;\n      ],\n      [\n         \&quot;(NODE FALSE 1 (NODE FALSE 2 FALSE)) (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) ((NODE FALSE 1 FALSE))) FALSE A B\&quot;,\n         \&quot;B\&quot;\n      ],\n      [\n         \&quot;(NODE (NODE FALSE 1 FALSE) 2 (NODE FALSE 3 FALSE)) (h:j:k:t: Y (f: a:b: a (l:v:r:t: b (x:y:z:t: (AND (EQ v y) (AND (f l x) (f r z)))) FALSE) (b (l:v:r:t: FALSE) TRUE)) (NODE h j k) ((NODE (NODE FALSE 1 FALSE) 2 (NODE FALSE 4 FALSE)))) FALSE A B\&quot;,\n         \&quot;B\&quot;\n      ]\n   ]\n}\n&quot;;</code></pre></section></div></main></body></html>